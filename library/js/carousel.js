/**
 * Create an accessible JavaScript carousel out of any unordered list of tiles. Each tile should be placed in a list item `li` within a container `ul`. Additional markup is generated by JavaScript, and several required style definitions are included in a global stylesheet. These styles are external instead of plugin-generated so they can be overridden easily if neccessary.
 *
 * Tiles can contain any html content but must be equal in width. Measurement for the overall carousel and individual tiles is based on the width of the first tile. Height can vary, although because the images are lazy loaded, image heights are evaluated just-in-time. This can lead to a slight page jump if a hidden tile is taller than the visible tiles once its images are loaded. CSS can be used to style the "previous" and "next" buttons, as well as the pagination menu (if pagination is enabled).
 *
 * Instantiate the carousel(s) by calling the plugin on an element or elements and passing an optional options object.
 *
 * Requires x.js
 *
 * @demo demo.php
 *
 * @example
 * SOURCE HTML STRUCTURE
 * <ul class="example-carousel">
 *      <li><img src="library/images/test-image-1.jpg" alt="" /></li>
 *      <li><img src="library/images/test-image-2.jpg" alt="" /></li>
 *      <li><img src="library/images/test-image-3.jpg" alt="" /></li>
 *      <li><img src="library/images/test-image-4.jpg" alt="" /></li>
 *      <li><img src="library/images/test-image-5.jpg" alt="" /></li>
 * </ul>
 *
 * var options = {
 *      parent: document.querySelector('.example-carousel')
 * }
 * var carousel1 = core();
 * carousel1.init(options);
 *
 *
 * @title Example #1: Default Instantiation
 * @syntax javascript
 * @desc Instantiation using default settings: single item carousel, one tile displayed at a time, advances one tile at a time, does not loop and does not display pagination. Note: the `carousel` class is not required for instantiation - any selector can be used.
 *
 *
 * @param Object options
 * @option Number tilesPerFrame Number of tiles to display per frame. Default is 1.
 * @option String incrementMode Whether to move the carousel by frame or single tile. Accepted values are `frame` and `tile`. Default is `frame`.
 * @option Boolean wrapControls Default is `false`. If `true`, a wrapper is placed around the prev/next links and pagination and centered.
 * @option String prevText Default is `Previous`. Set controls previous button text.
 * @option String nextText Default is `Next`. Set controls next button text.
 * @option Number wrapperDelta Change wrapper width by this pixel value. Default is 0.
 * @option Number viewportDelta Change viewport width by this pixel value. Default is 0.
 * @option Function preFrameChange Callback fired before the transitional frame animation.
 * @option Function postFrameChange Callback fired after the transitional frame animation.
 *
 * @name carousel
 */
define(

    [
        'vendor/x',
    ],

    function( x ) {

        'use strict';

        // Make sure to use the correct case for IE
        var tabindex = ( function() {

            var ieTest = document.createElement( 'li' ).getAttributeNode( 'tabindex' )
                , rtnVal = ieTest ? 'tabIndex' : 'tabindex'
                ;

            ieTest = null;

            return rtnVal;
        })();

        var defaults = {
            element: null,
            prevText: 'Previous',
            nextText: 'Next',
            tilesPerFrame: 1,
            incrementMode: 'frame', // tile or frame
            wrapControls: false,
            accessible: true,
            preFrameChange: null,
            postFrameChange: null,
            ready: null,
            wrapperClass: '',
            preventNavDisable: false,
            tileClass: 'carousel-tile'
        };

        var activeClass = 'state-visible'
            , inactiveClass = 'state-hidden'
            ;

        // Options that require integers
        var defaultInts = [ 'tilesPerFrame', 'wrapperDelta', 'viewportDelta' ];

        // Define templates
        var templates = {
            wrapper: [ 'div', 'carousel-wrapper' ],
            viewport: [ 'div', 'carousel-viewport' ],
            button: [ 'button' ],
            controls: [ 'div', 'carousel-controls' ],
            controlsWrapper: [ 'div', 'carousel-controls-wrapper' ]
        };

        // Compile templates
        for ( var template in templates ) {

            if ( templates.hasOwnProperty( template ) ) {

                if ( !templates[ template ][ 1 ] ) {

                    templates[ template ] = document.createElement( templates[ template ][ 0 ] );
                    continue;
                }

                var tempTmpl = document.createElement( templates[ template ][ 0 ] );
                tempTmpl.setAttribute( 'class', templates[ template ][ 1 ] );
                templates[ template ] = tempTmpl;
            }
        }

        /**
         * Returns the outer width of an element (emulates jQuery's outerWidth method)
         *
         * @method outerWidth
         * @param {Object} element HTML element
         * @return {Number} Outer width value of requested element
         * @private
         */
        function outerWidth( element ) {

            var width = element.offsetWidth
              , style = getComputedStyle( element ) || element.currentStyle; // element.currentStyle is for IE8

            width += parseInt( style.marginLeft, 10 ) + parseInt( style.marginRight, 10 );

            return width;
        }

        /**
         * Returns the outer height of an element (emulates jQuery's outerHeight method)
         *
         * @method outerHeight
         * @param {Object} element HTML element
         * @return {Number} Outer height value of requested element
         * @private
         */
        function outerHeight( element ) {

            var height = element.offsetHeight
              , style = getComputedStyle( element ) || element.currentStyle; // element.currentStyle is for IE8

            height += parseInt( style.marginTop, 10 ) + parseInt( style.marginBottom, 10 );

            return height;
        }

        /**
         * Inserts an HTML element after another HTML element (like jQuery's insertAfter and after methods)
         *
         * @method insertAfter
         * @param {Object} newNode HTML element to be inserted
         * @param {Object} targetNode HTML element newNode will be inserted after
         * @return {Object} newNode HTML element
         * @private
         */
        function insertAfter( newNode, targetNode ) {

            if ( !targetNode.parentNode ) throw new Error( 'insertAfter failed. The targetNode argument has no parentNode.' );

            targetNode.parentNode.insertBefore( newNode, targetNode.nextSibling );

            return newNode;
        }

        /**
         * Using addEvent method for backward compatibility with IE8
         *
         * @method addEvent
         * @param {Object} obj Element which will have listener attached to it
         * @param {String} evt Name of event to listen for
         * @param {Function} fn Event listener
         * @param {Boolean} capture Listen for events during capture phase, rather than bubbling phase (optional)
         * @author John Resig: http://ejohn.org/projects/flexible-javascript-events
         * @private
         */
        function addEvent( obj, evt, fn, capture ) {
            
            if ( obj.addEventListener ) {
                if ( !capture ) capture = false;
                obj.addEventListener( evt, fn, capture );

            }

            else if ( obj.attachEvent ) {

                obj[ 'e' + evt + fn ] = fn;
                obj[ evt + fn ] = function() { obj[ 'e' + evt + fn ]( window.event ); };
                obj.attachEvent( 'on' + evt, obj[ evt + fn ] );
            }
        }

        /**
         * Using removeEvent method for backward compatibility with IE8
         *
         * @method removeEvent
         * @param {Object} obj Element from which to remove listener
         * @param {String} evt Name of event to remove
         * @param {Function} fn Event listener
         * @author John Resig: http://ejohn.org/projects/flexible-javascript-events
         * @private
         */
        function removeEvent( obj, evt, fn ) {
            
            if ( obj.removeEventListener ){
                obj.removeEventListener( evt, fn, false );
            }
            else if ( obj.detachEvent ) {
                obj.detachEvent( 'on' + evt, obj[ evt + fn ] );
                obj[ evt + fn ] = null;
            }
        }
        
        /**
         * Provides a more accurate object type string than typeof operator
         *
         * @method getObjType
         * @param {Object} obj Object to be evaluated
         * @return {String} Bracketed specific object type name, i.e. [object Array]
         * @private
         */
        function getObjType( obj ) {
            
            return Object.prototype.toString.call( obj );
        }

        /**
         * Determine CSS transition support
         *
         * @method getTransSupport
         * @return {Object} Data object containing supported flag and corresponding data, if any
         * @author http://stackoverflow.com/a/9090128
         * @private
         */
        function getTransSupport() {

            var key,
                transStr,
                el = document.createElement( 'div' ),
                vendorLookup = {
                    'std': {
                        prefix: '',
                        endEvt: 'transitionend'
                    },
                    'webkit': {
                        prefix: '-webkit-',
                        endEvt: 'webkitTransitionEnd'
                    },
                    'mozilla': {
                        prefix: '-moz-',
                        endEvt: 'transitionend'
                    },
                    'opera': {
                        prefix: '-o-',
                        endEvt: 'otransitionend'  // oTransitionEnd in very old Opera
                    }
                };

            for ( key in vendorLookup ) {

                if ( vendorLookup.hasOwnProperty( key ) ) {

                    transStr = vendorLookup[ key ].prefix + 'transition';

                    if ( el.style[ transStr ] !== undefined ) {

                        // If transition support found, stop loop and return populated object
                        if ( key === 'std' ) vendorLookup[ key ].prefix = '-webkit-'; //hack for some webkit browsers

                        return {
                            supported: true,
                            data: vendorLookup[ key ]
                        };
                    }
                }
            }

            // Return empty object if no transition support found
            return {
                supported: false
            };
        }

        /**
         * Toggles class on an HTML element (mimics addClass and removeClass jQuery methods)
         *
         * @method toggleClass
         * @param {HTML Element} elem Element which class will be toggled on (required)
         * @param {String} elemClass Class name to be toggled (required)
         * @param {Boolean} add Flag which will force adding or removal of class (optional)
         * @private
         */
        function toggleClass( elem, elemClass, add ) {

            if ( typeof elem === 'undefined' || typeof elemClass === 'undefined' ) {
                return;
            }

            var classArr = elem.className.split(' ');
            var classIdx = classArr.indexOf( elemClass );

            // Element already has class, so remove unless add operation specified (add=true)
            if ( classIdx !== -1 && add !== true ) {

                classArr.splice( classIdx, 1 );
            }

            // Element doesn't have class, so add unless remove operation specified (add=false)
            else if ( classIdx === -1 && add !== false ) {

                classArr.push( elemClass );
            }

            elem.className = classArr.join(' ');
        }

        /**
         * Carousel core code
         *
         * @module carousel
         */
        var core = {

            /**
             * Sets up carousel environment
             *
             * @method setup
             * @param {Object} options Configuration object
             * @public
             */
            setup: function( options ) {

                var self = this;

                self.cacheObj = {};
                self.element = options.element;
                self.options = self.x.extend( {}, defaults, options );

                // Make sure the options are integers
                for ( var i = 0; i < defaultInts.length; i++ ) {

                    self.options[ defaultInts[ i ] ] = parseInt( self.options[ defaultInts[ i ] ], 10 );
                }

                // Add utilities to the API passed to plugins
                self.x.outerWidth = outerWidth;
                self.x.outerHeight = outerHeight;
                self.x.insertAfter = insertAfter;
                self.x.addEvent = addEvent;
                self.x.removeEvent = removeEvent;
                self.x.getObjType = getObjType;
                self.x.getTransSupport = getTransSupport;
                self.x.toggleClass = toggleClass;

                // Setup plugins
                self.setupPlugins();

                self.init();
            },

            /**
             * Initializes all carousel functionality
             *
             * @method init
             * @public
             */
            init: function() {

                this.x.publish( this.ns + '/init/before' );

                var rtnObj
                    , self              = this
                    , options           = self.options
                    , carousel          = self.element
                    , parentNode        = carousel.parentNode
                    , nextSibling       = carousel.nextSibling
                    , wrapper           = templates.wrapper.cloneNode( true )
                    , viewport          = templates.viewport.cloneNode( true )
                    , tilesPerFrame     = options.tilesPerFrame
                    ;
                
                // Save original tiles per frame data
                options.origTilesPerFrame = tilesPerFrame;
                    
                // Make the main elements available to `this`
                self.parentNode = carousel.parentNode;
                self.wrapper = wrapper;
                self.carousel = carousel;
                self.viewport = viewport;

                // Remove and build the carousel
                parentNode.removeChild( carousel );
                wrapper.appendChild( viewport );
                viewport.appendChild( carousel );

                // Replace the carousel
                if ( nextSibling ) {
                    insertAfter( wrapper, nextSibling );
                }
                
                else {
                    parentNode.appendChild( wrapper );
                }

                // Determine CSS transition support
                rtnObj = getTransSupport();
                self.cache( 'supportsTransitions', rtnObj.supported );
                self.cache( 'transitionData', rtnObj.data );

                // Build out the frames and state object
                self.initState();

                self.buildNavigation();

                // Listen for focus on tiles
                var panels = carousel.querySelectorAll( '.' + options.tileClass );

                for ( var i = 0, len = panels.length; i < len; ++i ) {

                    addEvent( panels[ i ], 'focus', self.focusHandler );
                    addEvent( panels[ i ], 'blur', self.focusHandler );
                }

                // self.initSwipe();

                if ( options.ready ) {

                    options.ready.call( self, self.state );
                }

                self.x.publish( self.ns + '/init/after' );
            },

            // initSwipe: function() {

            //     var origin
            //         , stopMove
            //         , transCache = ''
            //         , self = this
            //         , options = self.options
            //         , state = self.state
            //         , tileWidth = self.cache( 'tileWidth' ) / window.devicePixelRatio //adjust for Retina
            //         , touchData = {}
            //         , elem = self.carousel
            //         , noTrans = 'carousel-no-transition'
            //         , evtDetail = { 'detail': { data: touchData } }
            //         , tilePercent = self.cache( 'tilePercent' )
            //         , transitionData = self.cache( 'transitionData' )
            //         , vendorPrefix = ( transitionData && typeof transitionData.prefix !== 'undefined' ) ? transitionData.prefix : ''
            //         , transformAttr = vendorPrefix + 'transform'
            //         , dragThreshold = function( deltaX ) {

            //             return Math.abs( deltaX ) > 4;
            //         }
            //         , setData = function( e ) {

            //             var touches = e.touches || e.originalEvent.touches;

            //             if ( e.type === 'touchstart' ) {

            //                 origin = {
            //                     x : touches[ 0 ].pageX,
            //                     y: touches[ 0 ].pageY
            //                 };
            //             }

            //             stopMove = false;

            //             if ( touches[ 0 ] && touches[ 0 ].pageX ) {

            //                 touchData.touches = touches;
            //                 touchData.deltaX = touches[ 0 ].pageX - origin.x;
            //                 touchData.deltaY = touches[ 0 ].pageY - origin.y;
            //                 touchData.w = tileWidth;
            //                 touchData.h = tileWidth;
            //                 touchData.xPercent = touchData.deltaX / touchData.w;
            //                 touchData.yPercent = touchData.deltaY / touchData.h;
            //                 touchData.srcEvent = e;
            //             }

            //         }
            //         , emitEvents = function( e ){

            //             var thisEvt;

            //             setData( e );

            //             if ( touchData.touches.length === 1 ) {

            //                 thisEvt = new CustomEvent( self.ns + '.drag' + e.type.split( 'touch' )[ 1 ], evtDetail );

            //                 elem.dispatchEvent( thisEvt );
            //             }
            //         };

            //     /* 
            //      *  Native touch event listeners
            //      */
            //     addEvent( elem, 'touchstart', function( e ) {

            //         toggleClass( elem, noTrans, true );

            //         transCache = elem.style.transform;

            //         emitEvents( e );
            //     });

            //     addEvent( elem, 'touchmove', function( e ) {

            //         if ( Math.abs( touchData.deltaX ) > 10 ) {

            //             if ( e && e.preventDefault ) {

            //                 e.preventDefault();
            //             }
            //         }

            //         else if ( Math.abs( touchData.deltaY ) > 3 ) {

            //             stopMove = true;
            //         }

            //         if ( !stopMove ) {

            //             setData( e );
            //             emitEvents( e );
            //         }
            //     });

            //     addEvent( elem, 'touchend', function( e ) {

            //         toggleClass( elem, noTrans, false );
            //         emitEvents( e );
            //     });

            //     /* 
            //      *  Custom event listeners
            //      */
            //     addEvent( elem, self.ns + '.dragmove', function( e ) {

            //         if ( Math.abs( touchData.deltaY ) > Math.abs( touchData.deltaX ) ) return;
            
            //         if ( !dragThreshold( touchData.deltaX ) ) return;
                
            //         var currentPosition = state.index
            //             , maxPosition = state.curTileLength - options.tilesPerFrame
            //             , forward = touchData.deltaX < 0
            //             , deltaX = Math.abs( touchData.deltaX )
            //             , nextIndex = forward ? currentPosition + 1 : currentPosition - 1
            //             , peekMod = forward ? options.tilesPerFrame - 1 : 0
            //             , peekIndex = nextIndex + peekMod
            //             , translateAmt = tilePercent * currentPosition
            //             , transformStr = 'translateX(calc(-' + translateAmt + '% + ' + touchData.deltaX + 'px))'
            //             // , calcPercent = currentPosition * -100
            //             // peeking
            //             // , calcOffset = currentPosition > 0 ? currentPosition * 30 : 0
            //             // , calcPosition = calcOffset + touchData.deltaX
            //             // , positionStr = 'calc(' + calcPercent + '% + ' + calcPosition + 'px)'
            //             // end peeking
            //             // , positionStr = 'calc(' + calcPercent + '% + ' + touchData.deltaX + 'px)'
            //             // , isFirst = currentPosition === 0 && touchData.deltaX > 0
            //             // , isLast = currentPosition === maxPosition && touchData.deltaX < 0
            //             ;
                    
            //         // if ( isFirst || isLast ) return;

            //         elem.style.transform = transformStr;
            //         elem.style[ transformAttr ] = transformStr;

            //         if ( deltaX >= ( tileWidth / 2 ) ) {

            //             toggleClass( state.tileArr[ peekIndex ], inactiveClass, false );
            //             toggleClass( state.tileArr[ peekIndex ], activeClass, true );
            //         }
            //     });

            //     addEvent( elem, self.ns + '.dragend', function( e ) {

            //         if ( !dragThreshold( touchData.deltaX ) ) return;
            
            //         self.x.publish( self.ns + '/move' );
            
            //         var newSlide = Math.abs( touchData.deltaX ) >= tileWidth
            //             , currentPosition = state.index
            //             , maxPosition = state.curTileLength - options.tilesPerFrame
            //             // , isFirst = currentPosition === 0 && touchData.deltaX > 0
            //             // , isLast = currentPosition === maxPosition && touchData.deltaX < 0
            //             , forward = touchData.deltaX < 0
            //             , nextIndex = forward ? currentPosition + 1 : currentPosition - 1
            //             ;
            
            //         // if ( isFirst || isLast ) return;
                
            //         // Navigation threshold met, navigate carousel
            //         if ( newSlide ) {

            //             console.log(tileWidth, Math.abs( touchData.deltaX ));
                
            //             var thisMethod = forward ? self.nextFrame : self.prevFrame;

            //             toggleClass( state.curTile, activeClass, false );
            //             toggleClass( state.curTile, inactiveClass, true );

            //             toggleClass( state.tileArr[ nextIndex ], inactiveClass, false );
            //             toggleClass( state.tileArr[ nextIndex ], activeClass, true );
            
            //             thisMethod.call( self );
            //         }

            //         // Threshold not met, reset carousel to previous position
            //         else {

            //             toggleClass( elem, noTrans, false );
                        
            //             elem.style.transform = transCache;
            //             elem.style[ transformAttr ] = transCache;

            //             transCache = '';
            //         }
            //     });
            // },

            /**
             * Overrides internal method with provided function
             *
             * @method override
             * @param {String} name Name of internal method to override
             * @param {Function} func Function to replace internal method
             * @return {Function} Replaced internal method
             * @public
             */
            override: function( name, func ) {

                if ( !this[ name ] ) { return; }

                var origMethod = this[ name ].bind( this );

                this[ name ] = func;

                return origMethod; //return overidden method so that it can still be called if necessary
            },

            /**
             * Event listener for focus/blur events on each tile: adds class name to focused tile (attached in init)
             *
             * @method focusHandler
             * @param {Event} e Event object returned after focus/blur event is fired
             * @public
             */
            focusHandler: function( e ) {

                var cls = ' state-focus' // TODO Replace string
                    , target = e.target || e.srcElement // IE uses srcElement
                    ;

                // Using 'className' to support IE8
                if ( e.type === 'focus' ) target.className = target.className + cls;
                else target.className = target.className.replace( cls, '' );
            },

            /**
             * Sets/reads cached variables so that they are available to all methods and plugins
             *
             * @method cache
             * @param {String} key Name of variable to be cached
             * @param {Any} value Value of variable to be cached (optional)
             * @return {Object} {Any} Value of requested variable (read) or entire cache object (set) 
             * @public
             */
            cache: function( key, value ) {

                this.x.publish( this.ns + '/cache/before', key, value );

                var cache = this.cacheObj
                    , query = cache[ key ] !== 'undefined' ? cache[ key ] : undefined
                    ;

                if ( typeof value === 'undefined' ) {
                    return query;
                }

                cache[ key ] = value;

                this.x.publish( this.ns + '/cache/after', key, value );

                return cache;
            },
            
            /**
             * Re-initializes all carousel functionality
             *
             * @method reinit
             * @public
             */
            reinit: function() {
                
                this.x.publish( this.ns + '/reinit/before' );
                
                this.buildFrames();
                
                this.rebuildNavigation();
                
                this.x.publish( this.ns + '/reinit/after' );
            },
            
            /**
             * Updates properties in configuration options object, and runs reinit if necessary
             *
             * @method updateOptions
             * @param {Object} optsObj Object containing options properties to update
             * @return {Object} Updated options object
             * @public
             */
            updateOptions: function( optsObj ) {
                
                var rebuild;

                if ( getObjType( optsObj ) !== '[object Object]' ) return false;
                    
                rebuild = ( typeof optsObj.tilesPerFrame === 'number' && optsObj.tilesPerFrame !== this.options.tilesPerFrame ) ? true : false;
                
                this.x.extend( this.options, optsObj );
                
                if ( rebuild ) {

                    this.reinit();
                }
            
                return this.options;
            },
            
            /**
             * Updates properties in state object
             *
             * @method updateState
             * @param {Object} stateObj Object containing state properties to update
             * @return {Object} Updated state object
             * @public
             */
            updateState: function( stateObj ) {
                
                if ( getObjType( stateObj ) !== '[object Object]' ) return false;
                    
                this.x.extend( this.state, stateObj );
            
                return this.state;
            },

            /**
             * Initializes state object
             *
             * @method initState
             * @public
             */
            initState: function() {

                this.x.publish( this.ns + '/initState/before' );

                var self                = this
                    , carousel          = self.carousel
                    , tileArr           = carousel.children
                    , options           = self.options
                    , tilesPerFrame     = options.tilesPerFrame
                    , origTileLength    = tileArr.length
                    , curTileLength     = origTileLength
                    , frameLength       = Math.ceil( curTileLength / tilesPerFrame )
                    , state = {
                        index: 0,
                        prevIndex: false,
                        tileArr: tileArr,
                        origTileLength: origTileLength,
                        curTileLength: curTileLength,
                        curTile: false,
                        frameArr: [],
                        curFrameLength: frameLength,
                        curFrame: [],
                        frameIndex: 0,
                        prevFrameIndex: 0,
                        dom: {
                            wrapper: self.wrapper,
                            viewport: self.viewport,
                            carousel: self.element,
                            controls: self.controls,
                            prevBtn: self.prevBtn,
                            nextBtn: self.nextBtn
                        }
                    }
                    ;

                // Cache internal vars for later use
                self.cache( 'origWrapperClass', self.wrapper.className );
                self.cache( 'tilePercent', 100 );

                self.state = state;

                self.toggleAria( tileArr, 'add', options.tileClass ); //init tile classes (all tiles hidden by default)

                // Build the normalized frames array
                self.buildFrames();

                self.x.publish( self.ns + '/initState/after' );
            },
            
            /**
             * Populates state object, including width calculations based on tilesPerFrame
             *
             * @method buildFrames
             * @public
             */
            buildFrames: function() {
                
                this.x.publish( this.ns + '/buildFrames/before' );
                
                var tiles
                    , thisFrame
                    , frameStart
                    , frameEnd
                    , carEnd
                    , self              = this
                    , state             = self.state
                    , tileArr           = state.tileArr
                    , options           = self.options
                    , tilesPerFrame     = options.tilesPerFrame
                    , origWrapperClass  = self.cache( 'origWrapperClass' )
                    ;

                self.toggleAria( state.tileArr, 'add' ); //hide all tiles
                
                state.frameArr = [];
                
                for ( var sec = 0, len = tileArr.length / tilesPerFrame, count = 1;
                        sec < len;
                        sec++, count++ ) {

                    // This is crashing IE8 due to tileArr being a host object (HTMLCollection) instead of a JavaScript object
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Streamlining_cross-browser_behavior
                    // Every way I try to get around it, including the MDN shim, still causes IE8 to crash
                    tiles = Array.prototype.slice.call( tileArr, tilesPerFrame * sec, tilesPerFrame * count );

                    // var tiles = [];
                    // for ( var i = tilesPerFrame * sec, ii = 0, end = tilesPerFrame * count; i < end; i++, ii++) {
                    //     console.log(i);
                    //     console.log(ii);
                    //     console.log(end);
                    //     console.log(' ');
                    //     tiles[ii] = tileArr[i];
                    // }

                    state.frameArr.push( tiles );
                }

                state.curTile           = state.tileArr[ state.index ];
                state.curTileLength     = tileArr.length;
                state.curFrameLength    = Math.ceil( state.curTileLength / tilesPerFrame );
                state.frameIndex        = Math.ceil( state.index / tilesPerFrame );
                state.prevFrameIndex    = state.frameIndex;
                state.curFrame          = state.frameArr[ state.frameIndex ];

                self.wrapper.setAttribute( 'class', origWrapperClass + ' ' + options.wrapperClass );

                // tilePercent = ( parseInt( ( 100 / options.tilesPerFrame ) * 1000 ) ) / 1000;
                // tileStyle = 'width: ' + tilePercent + '%; ';
                //
                // for ( var i = 0; i < tileArr.length; i++ ) {
                //     tileArr[ i ].setAttribute( 'style', tileStyle );
                //                     // tileArr[ 0 ].classList.add( 'component-container' ); // !TODO: Replace string
                //                     // carousel.appendChild( tileArr[ 0 ] );
                // }

                // Cache measurement vars
                self.cache( 'tileDelta', ( options.tilesPerFrame * state.curFrameLength ) - state.curTileLength );
                self.cache( 'tileWidth', outerWidth( state.curTile ) );
                // self.cache( 'tileHeight', outerHeight( state.tileArr[ state.index ] ) );
                self.cache( 'trackPercent', 100 * state.curTileLength );
                self.cache( 'trackWidth', self.cache( 'tileWidth' ) * state.curTileLength );
                // self.cache( 'frameWidth', options.tilesPerFrame * self.cache( 'tileWidth' ) );
                
                //call calculate - updates state (publish)
                //dom styler - applies calculations (subscribed)
                self.calcDimensions( tilesPerFrame );

                self.updateDimensions();
                
                // Update position of carousel based on index
                self.updatePosition( state.index );
                
                // Determine current frame based on increment mode
                if ( options.incrementMode === 'frame' ) { //frame increment
                    
                    thisFrame = state.curFrame;
                }
                
                else { //tile increment
                    
                    thisFrame = [];
                    
                    frameEnd = state.index + tilesPerFrame;
                    carEnd = state.curTileLength;
                    
                    if ( frameEnd > carEnd ) {
                        
                        frameStart = carEnd - tilesPerFrame;
                        frameEnd = carEnd;
                    }
                    
                    else {

                        frameStart = state.index;
                    }
                    
                    for ( var i = frameStart; i < frameEnd; i++ ) {

                        thisFrame.push( state.tileArr[ i ] );
                    }
                }
                
                self.toggleAria( thisFrame, 'remove' ); //makes tiles in current frame visible
                
                self.x.publish( self.ns + '/buildFrames/after' );
            },

            /**
             * Synchronize state object after a state change, i.e. carousel going to previous/next tile/frame
             *
             * @method syncState
             * @param {Number} index New index of left-most visible tile
             * @return {Object} Updated state object
             * @public
             */
            syncState: function( index ) {

                this.x.publish( this.ns + '/syncState/before', this.state.index, index );

                var self                = this
                    , state             = self.state
                    , options           = self.options
                    , tilesPerFrame     = options.tilesPerFrame
                    , prevFrameIndex    = state.frameIndex
                    , newIndex          = index > state.curTileLength - tilesPerFrame ? state.curTileLength - tilesPerFrame
                                            : index < 0 ? 0
                                            : index
                    , frameIndex        = Math.ceil( newIndex / tilesPerFrame )
                    , isLastFrame       = newIndex === state.curTileLength - tilesPerFrame
                    , tileDelta         = self.cache( 'tileDelta' )
                    , updateObj = {
                        index: newIndex,
                        prevIndex: state.index,
                        curTile: isLastFrame && tileDelta && options.incrementMode === 'frame'
                                    ? state.tileArr[ newIndex + tileDelta ]
                                    : state.tileArr[ newIndex ],
                        curFrame: Array.prototype.slice.call( state.tileArr, newIndex, tilesPerFrame + newIndex ),
                        frameIndex: frameIndex,
                        prevFrameIndex: prevFrameIndex
                    };

                // Update state object
                self.updateState( updateObj );
                
                self.x.publish( self.ns + '/syncState/after', newIndex );

                return state;
            },
            
            /**
             * Goes to indicated tile without an animation
             *
             * @method updatePosition
             * @param {Number} index New index of left-most visible tile
             * @public
             */
            updatePosition: function( index ) {

                this.x.publish( this.ns + '/updatePosition/before' );

                var self = this
                    , carousel = self.element
                    , state = self.state
                    , tilePercent = self.cache( 'tilePercent' )
                    , translateAmt = tilePercent * index
                    , transformStr = 'translateX(-' + translateAmt + '%)'
                    , supportsTransitions = self.cache( 'supportsTransitions' )
                    , transitionData = self.cache( 'transitionData' )
                    , vendorPrefix = ( transitionData && typeof transitionData.prefix !== 'undefined' ) ? transitionData.prefix : ''
                    , transformAttr = vendorPrefix + 'transform'
                    , transitionAttr = vendorPrefix + 'transition'
                    ;
                
                if ( supportsTransitions ) {

                    // Prevent animation of re-position
                    carousel.style.transition = '';
                    carousel.style[ transitionAttr ] = '';
                    
                    carousel.style.transform = transformStr;
                    carousel.style[ transformAttr ] = transformStr;
                }

                // IE9
                else if ( 'msTransform' in carousel.style ) {

                    carousel.style.msTransform = transformStr;
                }
                
                self.toggleAria( state.tileArr, 'add' );
                self.toggleAria( state.curFrame, 'remove' );

                self.x.publish( self.ns + '/updatePosition/after' );
            },

            /**
             * Mediator function responsible for processing passed index, syncing state object, and navigating to appropriate tile
             *
             * @method navigate
             * @param {Number} index Index of left-most visible tile
             * @public
             */
            navigate: function( index ) {

                var newState = this.syncState( index );

                this.updatePosition( newState.index );
            },

            /**
             * Determines carousel and tile widths based on tilesPerFrame and total tiles
             *
             * @method calcDimensions
             * @param {Number} tilesPerFrame Number of visible tiles
             * @public
             */
            calcDimensions: function( tilesPerFrame ) {

                var state = this.state
                    , numTiles = state.tileArr.length
                    , percentIncrement = 100 / tilesPerFrame
                    , trackPercent = percentIncrement * numTiles
                    , tilePercent = 100 / ((trackPercent / 100) * tilesPerFrame)
                    , tileWidth = this.cache( 'tileWidth' )
                    , trackWidth = this.cache( 'trackWidth' )
                    ;

                this.cache( 'trackPercent', trackPercent );
                this.cache( 'tilePercent', tilePercent );

                // make pixel values?
                trackWidth = tileWidth * numTiles;
            },

            /**
             * Updates dimensions of carousel and tiles based on new values provided by calcDimensions
             *
             * @method updateDimensions
             * @public
             */
            updateDimensions: function() {

                var state = this.state
                    , tileArr = state.tileArr
                    , tilePercent = this.cache( 'tilePercent' )
                    , tileStyle = tilePercent + '%'
                    , trackPercent = this.cache( 'trackPercent' )
                    , trackStyle = trackPercent + '%'
                    ;

                this.carousel.style.width = trackStyle;

                for ( var i = 0; i< tileArr.length; i++ ) {

                    tileArr[ i ].style.width = tileStyle;
                }
            },

            /**
             * Builds out controls container and previous/next buttons
             *
             * @method buildNavigation
             * @public
             */
            buildNavigation: function() {

                this.x.publish( this.ns + '/navigation/before' );

                var text
                    , self              = this
                    , state             = self.state
                    , index             = state.index
                    , wrapper           = self.wrapper
                    , options           = self.options
                    , controls          = templates.controls.cloneNode( true )
                    , controlsParent    = templates.controlsWrapper.cloneNode( true )
                    , controlsWrapper   = options.wrapControls ? controls : wrapper
                    , prevFrame         = 'prevFrame' // TODO Replace string
                    , nextFrame         = 'nextFrame' // TODO Replace string
                    , hasNavInited      = self.cache( 'hasNavInited' )
                    ;

                self.controls = controls;
                self.controlsWrapper = controlsWrapper;

                text = options.prevText;
                self.prevBtn = templates.button.cloneNode( true );
                self.prevBtn.setAttribute( 'class', prevFrame );
                self.prevBtn.setAttribute( 'data-prev', '' );
                self.prevBtn.innerHTML = text;

                text = options.nextText;
                self.nextBtn = templates.button.cloneNode( true );
                self.nextBtn.setAttribute( 'class', nextFrame );
                self.nextBtn.setAttribute( 'data-next', '' );
                self.nextBtn.innerHTML = text;

                // Disable buttons if there is only one frame
                if ( state.curTileLength <= options.tilesPerFrame ) {

                    self.prevBtn.disabled = true;
                    self.nextBtn.disabled = true;
                }

                // Disable prev button
                if ( !options.preventNavDisable && index === 0 ) self.prevBtn.disabled = true;

                self.state.dom.prevBtn = self.prevBtn;
                self.state.dom.nextBtn = self.nextBtn;
                self.state.dom.controls = self.controls;

                // Insert controls
                if ( !options.wrapControls ) {

                    self.x.publish( self.ns + '/navigation/controls/insert/before', wrapper, self.prevBtn, self.nextBtn );

                    wrapper.insertBefore( self.prevBtn, self.viewport );
                    insertAfter( self.nextBtn, self.viewport );

                    self.x.publish( self.ns + '/navigation/controls/insert/after', wrapper, self.prevBtn, self.nextBtn );

                }

                else {

                    self.x.publish( self.ns + '/navigation/controls/insert/before', controls, self.prevBtn, self.nextBtn );

                    controlsParent.appendChild( controls );
                    controls.appendChild( self.prevBtn );
                    controls.appendChild( self.nextBtn );
                    wrapper.appendChild( controlsParent );

                    self.x.publish( self.ns + '/navigation/controls/insert/after', controls, self.prevBtn, self.nextBtn );
                }

                // Set click events buttons
                // Using addEvent method for IE8 support
                if ( !hasNavInited ) {

                    addEvent( self.wrapper, 'click', self.handleNavigation.bind( self ) );
                }

                self.cache( 'hasNavInited', true );

                self.x.publish( self.ns + '/navigation/after' );
            },
            
            /**
             * Re-builds out controls container and previous/next buttons (removing any previously existing elements)
             *
             * @method rebuildNavigation
             * @public
             */
            rebuildNavigation: function() {
                
                if ( this.controlsWrapper ) {
                
                    this.x.publish( this.ns + '/navigation/rebuild/before' );
                    
                    // Double parentNode necessary since controlsWrapper element is getting overwritten with controls element
                    this.controlsWrapper.parentNode.parentNode.removeChild( this.controlsWrapper.parentNode );
                    
                    this.buildNavigation();
                
                    this.x.publish( this.ns + '/navigation/rebuild/after' );
                }
            },

            /**
             * Disables previous/next buttons at start/end of carousel
             *
             * @method updateNavigation
             * @public
             */
            updateNavigation: function() {

                var self = this
                    , state = self.state
                    , index = state.index
                    , options = self.options
                    , isFirst = index === 0
                    , isLast = index + self.options.tilesPerFrame >= state.curTileLength
                    ;
                
                if ( options.preventNavDisable ) return;
                
                if ( isFirst ) self.prevBtn.disabled = true;
                else self.prevBtn.disabled = false;

                if ( isLast ) self.nextBtn.disabled = true;
                else self.nextBtn.disabled = false;
            },

            /**
             * Event listener for all clicks on controls (attached in buildNavigation)
             *
             * @method handleNavigation
             * @param {Event} e Event object returned after click event is fired
             * @public
             */
            handleNavigation: function( e ) {

                var method
                    , target = e.target || e.srcElement // IE uses srcElement
                    ;

                if ( target.nodeName.toLowerCase() !== 'button' ) return;

                method = target.hasAttribute( 'data-next' ) ? 'nextFrame'
                    : target.hasAttribute( 'data-prev' ) ? 'prevFrame'
                    : false
                    ;

                if ( method ) this[ method ]();
            },

            /**
             * Navigates carousel back one tile/frame
             *
             * @method prevFrame
             * @return {Obj} Carousel object
             * @chainable
             * @public
             */
            prevFrame: function() {

                this.x.publish( this.ns + '/prevFrame/before' );

                var modifier = this.options.incrementMode === 'tile' ? 1 : this.options.tilesPerFrame
                    , index = this.state.index - modifier
                    ;

                this.navigate( index );

                this.x.publish( this.ns + '/prevFrame/after' );

                return this.carousel;
            },

            /**
             * Navigates carousel forward one tile/frame
             *
             * @method nextFrame
             * @return {Obj} Carousel object
             * @chainable
             * @public
             */
            nextFrame: function() {

                this.x.publish( this.ns + '/nextFrame/before' );

                var modifier = this.options.incrementMode === 'tile' ? 1 : this.options.tilesPerFrame
                    , index = this.state.index + modifier
                    ;

                this.navigate( index );

                this.x.publish( this.ns + '/nextFrame/after' );

                return this.carousel;
            },

            /**
             * Navigates carousel to arbitrary tile/frame
             *
             * @method jumpToFrame
             * @param {Number} frame Index of tile to navigate to
             * @return {Obj} Carousel object
             * @chainable
             * @public
             */
            jumpToFrame: function( frame ) {

                var self = this
                    , state = self.state
                    , options = self.options
                    , frame = parseInt( frame, 10 )
                    , tilesPerFrame = self.options.tilesPerFrame
                    , index = ( options.incrementMode === 'frame' ) ? 
                            frame * tilesPerFrame : frame
                    ;

                index = index < 0 ? 0 : index;

                if ( 
                    ( options.incrementMode === 'tile' && index === state.index ) ||
                    ( options.incrementMode === 'frame' && frame > state.curFrameLength )
                ) {

                    return self.carousel;
                }

                self.navigate( index );

                return self.carousel;
            },

            /**
             * Resets carousel tiles to original position
             *
             * @method reset
             * @return {Obj} Carousel object
             * @chainable
             * @public
             */
            reset: function() {

                var index = 0;

                this.navigate( index );

                return this.carousel;
            },

            /**
             * Toggles ARIA classes on tiles
             *
             * @method toggleAria
             * @param {Array} itemArray Array of tiles to add/remove ARIA classes from
             * @param {String} operation Operation mode (add=hide|remove=show)
             * @param {String} initClass Initial class name to add to tiles in itemArray (optional)
             * @public
             */
            toggleAria: function( itemArray, operation, initClass ) {

                var item
                    , classes
                    , i = 0
                    , self = this
                    , length = itemArray.length
                    , ariaHClass = ' state-hidden'
                    , ariaVClass = ' state-visible'
                    , rAriaHClass = /\sstate-hidden/
                    , rAriaVClass = /\sstate-visible/
                    , add = operation === 'add' ? true : false
                    , initClass = initClass ? ' ' + initClass : ''
                    , hasAriaInited = self.cache( 'hasAriaInited' )
                    ;

                for ( ; i < length; i++ ) {

                    item = itemArray[ i ];
                    classes = item.className + initClass;

                    if ( add ) classes = classes.replace( rAriaVClass, ariaHClass );
                    else classes = classes.replace( rAriaHClass, ariaVClass );

                    item.className = classes.replace( /^\s/, '' );

                    if ( !hasAriaInited ) {

                        item.className = item.className + ariaHClass;
                        item.setAttribute( tabindex, '-1' );
                    }

                    classes = null;
                }

                self.cache( 'hasAriaInited', true );
            }
        };

        // Define the carousel
        return x.define( 'carousel', core );
    }
);